#!/usr/bin/env nextflow
/* Pipeline to prepare the archaic VCFs and dbSNP for the gVCFs to annotated*
 * VCF pipeline                                                             *
 * Archaic SNP VCF steps:                                                   *
 *  tabix on masking BEDs -> (next step also filters based on masks)        *
 *  bcftools reheader (fix GQ header, scaffold headers, 3 REFs) -> tabix -> *
 *  bcftools merge (merge ACDV archaics into one VCF) -> tabix              *
 * dbSNP VCF steps:                                                         *
 *  NCBI_to_UCSC_map.awk (generate mapping of scaffold names) -|>           * 
 *  NCBI_UCSC_1kGP_compatible.awk (BED of compatible scaffolds) ->          *
 *  bcftools annotate (rename-chrs from NCBI to hs37d5) ->                  *
 *  bcftools view (only retain scaffolds present in hs37d5) -> tabix        */

//Default paths, globs, and regexes:
//Archaic VCFs:
params.arc_vcf_glob = "${projectDir}/archaic_VCFs/*.vcf.gz"
params.arc_bed_glob = "${projectDir}/archaic_BEDs/*.bed.gz"
//dbSNP VCF:
params.dbsnp = "/gpfs/gibbs/pi/tucci/pfr8/dbSNP/b${params.dbsnp_build}/GCF_000001405.25.gz"

//Reference-related parameters for the pipeline:
params.ref_prefix = "/gpfs/gibbs/pi/tucci/pfr8/refs"
params.ref = "${params.ref_prefix}/1kGP/hs37d5/hs37d5.fa"
params.asm_name = "hs37d5"

//Scaffold mapping files:
params.NCBI_to_UCSC_map = "/gpfs/gibbs/pi/tucci/pfr8/refs/NCBI/GRCh37.p13/GCF_000001405.25_GRCh37.p13_assembly_report.txt"
params.UCSC_to_TGP_map = "/gpfs/gibbs/pi/tucci/pfr8/refs/UCSC/hg19/g1kToUcsc_MTfixed.txt"

//Set up the file channels for the ref and its various index components:
//Inspired by the IARC alignment-nf pipeline
//fai is generated by samtools faidx, and dict is generated by Picard and used by GATK
ref = file(params.ref, checkIfExists: true)
ref_dict = file(params.ref.replaceFirst("[.]fn?a(sta)?([.]gz)?", ".dict"), checkIfExists: true)
ref_fai = file(params.ref+'.fai', checkIfExists: true)

//Scaffold mapping file channels:
ncbi_ucsc = file(params.NCBI_to_UCSC_map, checkIfExists: true)
ucsc_tgp = file(params.UCSC_to_TGP_map, checkIfExists: true)

//dbSNP VCF to adjust for hs37d5 compatibility:
dbsnp = file(params.dbsnp, checkIfExists: true)
dbsnp_idx = file(params.dbsnp+'.tbi', checkIfExists: true)

//Default parameter values:
//Regex for parsing the name and chromosome out from the archaic VCF or BED:
params.arc_chrom_regex = ~/^(\p{Alnum}+)_chr(\p{Alnum}+)$/
//We're expecting the filenames to conform to:
//^[sample name]_chr[1-9X][0-9]?(.mask)?[.](bed|vcf)[.]gz$

//Defaults for cpus, memory, and time for each process:
//Index input archaic masking BEDs
params.tabix_cpus = 1
params.tabix_mem = 1
params.tabix_timeout = '6h'
//Fix archaic VCFs (GQ header, scaffold headers, chr3 REF states, apply masks)
params.vcffix_cpus = 1
params.vcffix_mem = 4
params.vcffix_timeout = '12h'
//Merge fixed archaic VCFs
params.vcfmerge_cpus = 1
params.vcfmerge_mem = 8
params.vcfmerge_timeout = '24h'
//Generate NCBI to 1kGP scaffold mapping and scaffold compatibility BED
//Adjust dbSNP VCF to be compatible with 1kGP reference:
params.dbsnp_cpus = 1
params.dbsnp_mem = 16
params.dbsnp_timeout = '24h'

//Set up the channels of Archaic per-chromosome VCFs and their indices:
Channel
   .fromPath(params.arc_vcf_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find archaic VCFs matching glob: ${params.arc_vcf_glob}" }
   .map { a -> [ (a.getSimpleName() =~ params.arc_chrom_regex)[0][0], a] }
   .tap { arc_vcfs }
   .subscribe { println "Added ${it[1]} to arc_vcfs channel" }

Channel
   .fromPath(params.arc_vcf_glob+'.tbi', checkIfExists: true)
   .ifEmpty { error "Unable to find archaic VCF indices matching glob: ${params.arc_vcf_glob}.tbi" }
   .map { a -> [ (a.getSimpleName() =~ params.arc_chrom_regex)[0][0], a] }
   .tap { arc_vcf_indices }
   .subscribe { println "Added ${it[1]} to arc_vcf_indices channel" }

Channel
   .fromPath(params.arc_bed_glob, checkIfExists: true)
   .ifEmpty { error "Unable to find archaic masking BEDs matching glob: ${params.arc_bed_glob}" }
   .map { a -> [ (a.getSimpleName() =~ params.arc_chrom_regex)[0][0], a] }
   .tap { arc_beds_toindex }
   .subscribe { println "Added ${it[1]} to arc_beds_toindex channel" }

process tabix_beds {
   tag "${namechrom}"

   cpus params.tabix_cpus
   memory { params.tabix_mem.plus(256).plus(task.attempt.minus(1).multiply(256))+' MB' }
   time { task.attempt >= 2  ? '24h' : params.tabix_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   input:
   tuple val(namechrom), path(arcbed) from arc_beds_toindex

   output:
   tuple val(namechrom), path("${arcbed}") into arc_beds
   tuple val(namechrom), path("${arcbed}.tbi") into arc_bed_indices

   shell:
   '''
   module load !{params.mod_htslib}
   tabix -f !{arcbed}
   '''
}

//Had some issues with piping bcftools reheader and bcftools view (especially with -R),
// so we separate the steps and delete the intermediate files at the end.
//Also, I'm not using bcftools reheader -f, as it places the current scaffold at
// the top of the "contig" header list, so the order wouldn't be the same across
// VCFs...
process fix_arc_vcfs {
   tag "${namechrom}"

   cpus params.vcffix_cpus
   memory { params.vcffix_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '48h' : params.vcffix_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   input:
   tuple val(namechrom), path(arcvcf), path(arcbed) from arc_vcfs.combine(arc_beds, by: 0)
   tuple val(idx_namechrom), path(arcvcfidx), path(arcbedidx) from arc_vcf_indices.combine(arc_bed_indices, by: 0)
   path ref
   path ref_fai

   output:
   tuple val(chrom), path("${namechrom}_fixed.vcf.gz") into fixed_arc_vcfs
   tuple val(chrom), path("${namechrom}_fixed.vcf.gz.tbi") into fixed_arc_vcf_indices

   shell:
   chrom = (namechrom =~ params.arc_chrom_regex)[0][2]
   '''
   module load !{params.mod_htslib}
   module load !{params.mod_bcftools}
   bcftools view -h !{arcvcf} | \
      !{projectDir}/fixArchaicVCFheader.awk -v "asm=!{params.asm_name}" !{ref_fai} - | \
      bgzip -c > fixed_header.vcf.gz
   bcftools reheader -h fixed_header.vcf.gz -o !{namechrom}_fixedHeader.vcf.gz !{arcvcf}
   tabix -f !{namechrom}_fixedHeader.vcf.gz
   bcftools norm -N -f !{ref} -c s -Oz -o !{namechrom}_fixed_notfiltered.vcf.gz !{namechrom}_fixedHeader.vcf.gz
   tabix -f !{namechrom}_fixed_notfiltered.vcf.gz
   bcftools view -R !{arcbed} -Oz -o !{namechrom}_fixed.vcf.gz !{namechrom}_fixed_notfiltered.vcf.gz
   tabix -f !{namechrom}_fixed.vcf.gz
   rm fixed_header.vcf.gz
   rm !{namechrom}_fixedHeader.vcf.gz !{namechrom}_fixedHeader.vcf.gz.tbi
   rm !{namechrom}_fixed_notfiltered.vcf.gz !{namechrom}_fixed_notfiltered.vcf.gz.tbi
   '''
}

process arc_vcf_merge {
   tag "${chrom}"

   cpus params.vcfmerge_cpus
   memory { params.vcfmerge_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '72h' : params.vcfmerge_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/final_VCFs", mode: 'copy', pattern: 'ArchaicsMerged_chr*.vcf.g{z,z.tbi}'

   input:
   tuple val(chrom), path(vcfs) from fixed_arc_vcfs.groupTuple(by: 0, sort: true)
   tuple val(idx_chrom), path(vcfindices) from fixed_arc_vcf_indices.groupTuple(by: 0, sort: true)
   path ref
   path ref_fai

   output:
   tuple val(chrom), path("ArchaicsMerged_chr${chrom}.vcf.gz"), path("ArchaicsMerged_chr${chrom}.vcf.gz.tbi") into arc_vcf_merge_vcfs

   shell:
   '''
   module load !{params.mod_htslib}
   module load !{params.mod_bcftools}
   bcftools merge -m all -Oz -o ArchaicsMerged_chr!{chrom}.vcf.gz !{vcfs}
   tabix -f ArchaicsMerged_chr!{chrom}.vcf.gz
   '''
}

process dbsnp_compat {
//   tag ""

   cpus params.dbsnp_cpus
   memory { params.dbsnp_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '48h' : params.dbsnp_timeout }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/final_VCFs", mode: 'copy', pattern: 'dbSNP_*.vcf.g{z,z.tbi}'

   input:
   path ncbi_ucsc
   path ucsc_tgp
   path ref_fai
   path dbsnp
   path dbsnp_idx

   output:
   tuple path("dbSNP_${params.dbsnp_build}_${params.asm_name}.vcf.gz"), path("dbSNP_${params.dbsnp_build}_${params.asm_name}.vcf.gz.tbi") into dbsnp_compat_vcf

   shell:
   '''
   module load !{params.mod_htslib}
   module load !{params.mod_bcftools}
   !{projectDir}/NCBI_to_1kGP_map.awk !{ncbi_ucsc} !{ucsc_tgp} > ncbi_tgp_map.txt
   !{projectDir}/NCBI_UCSC_1kGP_compatible.awk ncbi_tgp_map.txt !{ref_fai} > ncbi_tgp_compatible.bed
   bcftools annotate --rename-chrs ncbi_tgp_map.txt -Oz -o dbSNP_!{params.dbsnp_build}_tgp_renamed_notfiltered.vcf.gz !{dbsnp}
   tabix -f dbSNP_!{params.dbsnp_build}_tgp_renamed_notfiltered.vcf.gz
   bcftools view -R ncbi_tgp_compatible.bed -Oz -o dbSNP_!{params.dbsnp_build}_!{params.asm_name}.vcf.gz dbSNP_!{params.dbsnp_build}_tgp_renamed_notfiltered.vcf.gz
   tabix -f dbSNP_!{params.dbsnp_build}_!{params.asm_name}.vcf.gz
   rm dbSNP_!{params.dbsnp_build}_tgp_renamed_notfiltered.vcf.gz dbSNP_!{params.dbsnp_build}_tgp_renamed_notfiltered.vcf.gz.tbi
   '''
}
